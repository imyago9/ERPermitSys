<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chromatic Dreamfield Â· Infinite Silk Strings</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #04060d;
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: soft-light;
      opacity: 0.62;
      background:
        radial-gradient(130vmax 130vmax at 50% 50%, rgba(255,255,255,0.05), rgba(0,0,0,0.40) 63%, rgba(0,0,0,0.86) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.012) 0 1px, rgba(0,0,0,0.012) 1px 2px);
    }

    .fallback {
      position: fixed;
      inset: 0;
      display: none;
      background:
        radial-gradient(95vmax 95vmax at 18% 28%, #2fd4ff66, transparent 58%),
        radial-gradient(88vmax 88vmax at 81% 69%, #ff58d366, transparent 60%),
        radial-gradient(76vmax 76vmax at 52% 84%, #7f6dff66, transparent 62%),
        linear-gradient(145deg, #0b1022 0%, #070b16 48%, #11183a 100%);
      animation: fallbackShift 18s ease-in-out infinite alternate;
      filter: saturate(1.3);
    }

    @keyframes fallbackShift {
      0%   { transform: scale(1.03) translate(-1.2%, -0.8%); filter: hue-rotate(0deg) saturate(1.14); }
      100% { transform: scale(1.09) translate(1.2%, 1.1%);  filter: hue-rotate(30deg) saturate(1.38); }
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <div class="fallback"></div>
  <div class="overlay"></div>

  <script>
    (() => {
      const canvas = document.getElementById('gl');
      const fallback = document.querySelector('.fallback');

      const gl = canvas.getContext('webgl', {
        alpha: false,
        antialias: true,
        depth: false,
        stencil: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
      });

      if (!gl) {
        fallback.style.display = 'block';
        return;
      }

      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const vertexSrc = `
        attribute vec2 a_pos;
        void main() {
          gl_Position = vec4(a_pos, 0.0, 1.0);
        }
      `;

      const fragmentSrc = `
        precision highp float;

        uniform vec2 u_res;
        uniform float u_time;
        uniform vec2 u_mouse;

        #define TAU 6.28318530718

        mat2 rot(float a) {
          float s = sin(a), c = cos(a);
          return mat2(c, -s, s, c);
        }

        float hash21(vec2 p) {
          p = fract(p * vec2(234.34, 435.345));
          p += dot(p, p + 34.23);
          return fract(p.x * p.y);
        }

        float noise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec2 u = f * f * (3.0 - 2.0 * f);

          float a = hash21(i + vec2(0.0, 0.0));
          float b = hash21(i + vec2(1.0, 0.0));
          float c = hash21(i + vec2(0.0, 1.0));
          float d = hash21(i + vec2(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
        }

        float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.55;
          mat2 m = mat2(1.7, 1.2, -1.2, 1.7);
          for (int i = 0; i < 6; i++) {
            v += a * noise(p);
            p = m * p;
            a *= 0.53;
          }
          return v;
        }

        float ridged(vec2 p) {
          float v = 0.0;
          float a = 0.52;
          mat2 m = mat2(1.55, -1.15, 1.15, 1.55);
          for (int i = 0; i < 5; i++) {
            float n = noise(p);
            n = 1.0 - abs(2.0 * n - 1.0);
            v += n * a;
            p = m * p;
            a *= 0.56;
          }
          return v;
        }

        vec2 flow(vec2 p, float t) {
          float a = fbm(p * 1.55 + vec2(0.0, t * 0.13));
          float b = fbm((p + vec2(4.2, -3.1)) * 1.95 + vec2(-t * 0.11, t * 0.09));
          float c = ridged(p * 2.4 - vec2(t * 0.07, t * 0.05));
          float ang = TAU * (a - b + c * 0.35);
          return vec2(cos(ang), sin(ang));
        }

        float filament(vec2 p, float t, float freq, float thick, float warp) {
          p += warp * vec2(
            sin(p.y * 1.7 + t * 0.7) + 0.5 * sin(p.y * 3.2 - t * 0.3),
            cos(p.x * 1.3 - t * 0.6) + 0.5 * cos(p.x * 2.6 + t * 0.25)
          );
          float f = abs(sin(p.x * freq + 0.8 * sin(p.y * 2.4 + t * 0.9) + t * 0.45));
          return smoothstep(thick, 0.0, f);
        }

        float stringField(vec2 p, float t) {
          float s = 0.0;
          vec2 q = p;
          float gain = 1.0;

          for (int i = 0; i < 6; i++) {
            float fi = float(i);

            vec2 v = flow(q * (1.35 + fi * 0.16), t + fi * 3.1);
            q += v * (0.18 + 0.04 * fi);
            q *= rot(0.35 + 0.1 * sin(t * 0.2 + fi * 1.3));

            float l1 = filament(q, t * (0.9 + fi * 0.06), 16.0 + fi * 7.0, 0.10 + fi * 0.015, 0.22 + 0.05 * fi);
            float l2 = filament(q + vec2(0.35, -0.22), -t * (0.7 + fi * 0.04), 13.0 + fi * 6.0, 0.11 + fi * 0.016, 0.20 + 0.04 * fi);

            s += (l1 * 0.66 + l2 * 0.55) * gain;
            q = q * 1.32 + vec2(0.8, -0.65);
            gain *= 0.68;
          }

          return s;
        }

        vec3 palette(float t) {
          vec3 a = vec3(0.54, 0.42, 0.64);
          vec3 b = vec3(0.44, 0.52, 0.36);
          vec3 c = vec3(1.0, 1.0, 1.0);
          vec3 d = vec3(0.00, 0.12, 0.25);
          return a + b * cos(TAU * (c * t + d));
        }

        float starLayer(vec2 uv, float t, float density, float size) {
          vec2 gv = uv * density;
          vec2 id = floor(gv);
          vec2 f = fract(gv) - 0.5;

          float r = hash21(id);
          float tw = 0.66 + 0.34 * sin(t * 2.9 + r * 60.0);
          float mask = smoothstep(0.996, 1.0, r);

          float core = smoothstep(size, 0.0, length(f));
          return mask * tw * core;
        }

        vec3 aces(vec3 x) {
          return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
        }

        void main() {
          vec2 frag = gl_FragCoord.xy;
          vec2 uv = (frag - 0.5 * u_res) / min(u_res.x, u_res.y);

          float t = u_time;
          vec2 m = (u_mouse / u_res - 0.5) * 2.0;
          m.x *= u_res.x / u_res.y;

          // camera drift
          vec2 p = uv;
          p *= 1.0 + 0.03 * sin(t * 0.25);
          p += 0.06 * vec2(sin(t * 0.38), cos(t * 0.42));
          p *= rot(0.11 * sin(t * 0.14));

          // recursive advection
          vec2 q = p;
          for (int i = 0; i < 3; i++) {
            float fi = float(i);
            q += 0.26 * flow(q * (1.8 + fi * 0.25), t + fi * 4.0);
            q *= rot(0.22 * sin(t * 0.11 + fi * 2.0));
          }

          // pointer as gentle attractor
          q += 0.18 * m * exp(-1.6 * length(uv));

          float cloud = fbm(q * 3.8 + vec2(t * 0.22, -t * 0.20));
          float detail = fbm(q * 9.7 - vec2(t * 0.60, t * 0.52));
          float ridge = ridged(q * 6.3 + vec2(-t * 0.17, t * 0.14));

          // braided string abstractions
          float stringsA = stringField(q * 1.15, t);
          float stringsB = stringField((q + vec2(0.14, -0.09)) * 1.12, -t * 0.86 + 5.2);
          float strings = stringsA * 0.62 + stringsB * 0.54;

          float rr = length(q);
          float aa = atan(q.y, q.x);
          float irid = 0.5 + 0.5 * cos(17.0 * rr - aa * 2.8 - t * 0.62);
          irid *= smoothstep(1.25, 0.0, rr);

          vec3 c0 = palette(0.08 + cloud * 0.95 + t * 0.010);
          vec3 c1 = palette(0.61 + detail * 0.72 - t * 0.008);
          vec3 col = mix(c0, c1, smoothstep(0.05, 0.95, cloud));

          col += vec3(0.20, 0.66, 1.00) * pow(max(ridge - 0.34, 0.0), 1.9) * 0.42;
          col += vec3(0.95, 0.35, 0.86) * pow(max(detail - 0.58, 0.0), 2.1) * 0.34;

          vec3 silk1 = vec3(0.20, 0.82, 1.00);
          vec3 silk2 = vec3(1.00, 0.36, 0.90);
          vec3 silk3 = vec3(0.72, 0.66, 1.00);

          col += silk1 * pow(stringsA, 1.22) * 0.40;
          col += silk2 * pow(stringsB, 1.24) * 0.36;
          col += silk3 * pow(strings, 1.45) * 0.22;

          col += vec3(0.78, 0.62, 1.00) * irid * 0.22;

          float halo = exp(-5.8 * dot(uv - m * 0.25, uv - m * 0.25));
          col += mix(vec3(0.20, 0.70, 1.00), vec3(1.00, 0.40, 0.90), 0.5 + 0.5 * sin(t * 0.4)) * halo * 0.18;

          // stars
          vec2 su = uv * vec2(u_res.x / u_res.y, 1.0);
          float stars = 0.0;
          stars += starLayer(su + vec2(t * 0.004, 0.0), t, 240.0, 0.16) * 0.9;
          stars += starLayer(su * 1.34 - vec2(t * 0.007, t * 0.002), t * 1.3, 330.0, 0.13) * 0.68;
          col += vec3(1.0, 0.98, 1.0) * stars;

          // film grain
          float grain = hash21(frag + vec2(t * 161.0, t * 91.0)) - 0.5;
          col += grain * 0.020;

          // bloom-ish response + anti-whiteout clamp
          float lum = dot(col, vec3(0.2126, 0.7152, 0.0722));
          col += col * smoothstep(0.80, 1.70, lum) * 0.12;
          col *= (1.0 - 0.12 * smoothstep(0.90, 1.80, lum));

          col = aces(max(col, 0.0));
          col = pow(col, vec3(0.94));

          float vign = smoothstep(1.55, 0.18, length(uv * vec2(1.08, 1.0)));
          col *= vign;

          gl_FragColor = vec4(col, 1.0);
        }
      `;

      function compileShader(type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const log = gl.getShaderInfoLog(shader) || 'Shader compile failed';
          gl.deleteShader(shader);
          throw new Error(log);
        }
        return shader;
      }

      function createProgram(vsSource, fsSource) {
        const vs = compileShader(gl.VERTEX_SHADER, vsSource);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
        const program = gl.createProgram();

        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        gl.deleteShader(vs);
        gl.deleteShader(fs);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          const log = gl.getProgramInfoLog(program) || 'Program link failed';
          gl.deleteProgram(program);
          throw new Error(log);
        }
        return program;
      }

      let program;
      try {
        program = createProgram(vertexSrc, fragmentSrc);
      } catch (err) {
        console.error(err);
        canvas.style.display = 'none';
        fallback.style.display = 'block';
        return;
      }

      const quad = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
      ]);

      const buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(program, 'a_pos');
      const uRes = gl.getUniformLocation(program, 'u_res');
      const uTime = gl.getUniformLocation(program, 'u_time');
      const uMouse = gl.getUniformLocation(program, 'u_mouse');

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const width = Math.max(1, Math.floor(window.innerWidth * dpr));
        const height = Math.max(1, Math.floor(window.innerHeight * dpr));

        if (canvas.width !== width || canvas.height !== height) {
          canvas.width = width;
          canvas.height = height;
        }

        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      const mouse = { x: 0.5, y: 0.5 };
      const target = { x: 0.5, y: 0.5 };

      function setPointer(clientX, clientY) {
        target.x = clientX / window.innerWidth;
        target.y = 1.0 - clientY / window.innerHeight;
      }

      window.addEventListener('mousemove', (e) => setPointer(e.clientX, e.clientY), { passive: true });
      window.addEventListener('touchmove', (e) => {
        const t = e.touches && e.touches[0];
        if (t) setPointer(t.clientX, t.clientY);
      }, { passive: true });
      window.addEventListener('resize', resize, { passive: true });

      resize();

      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      const t0 = performance.now();
      let running = true;
      let pausedAt = 0;

      function render(now) {
        if (!running) return;

        const elapsed = (now - t0 - pausedAt) * 0.001;
        const t = reducedMotion ? elapsed * 0.28 : elapsed;

        mouse.x += (target.x - mouse.x) * 0.036;
        mouse.y += (target.y - mouse.y) * 0.036;

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform1f(uTime, t);
        gl.uniform2f(uMouse, mouse.x * canvas.width, mouse.y * canvas.height);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      let hiddenStart = 0;
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          hiddenStart = performance.now();
          running = false;
        } else {
          if (hiddenStart) pausedAt += performance.now() - hiddenStart;
          running = true;
          requestAnimationFrame(render);
        }
      });

      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
