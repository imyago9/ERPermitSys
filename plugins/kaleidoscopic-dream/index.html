<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chromatic Infinite Strings Â· Hypertrip</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #03050d;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    .film {
      position: fixed;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: soft-light;
      opacity: 0.40;
      background:
        radial-gradient(145vmax 145vmax at 50% 50%, rgba(255,255,255,.04), rgba(0,0,0,.42) 64%, rgba(0,0,0,.92) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,.012) 0 1px, rgba(0,0,0,.012) 1px 2px);
    }
    .fallback {
      position: fixed;
      inset: 0;
      display: none;
      background:
        radial-gradient(95vmax 95vmax at 18% 28%, #22d3ee66, transparent 58%),
        radial-gradient(88vmax 88vmax at 81% 69%, #f472b666, transparent 60%),
        radial-gradient(76vmax 76vmax at 52% 84%, #818cf866, transparent 62%),
        linear-gradient(145deg, #0b1022 0%, #070b16 48%, #11183a 100%);
      animation: fallbackShift 18s ease-in-out infinite alternate;
      filter: saturate(1.3);
    }
    @keyframes fallbackShift {
      0%   { transform: scale(1.03) translate(-1.2%, -0.8%); filter: hue-rotate(0deg) saturate(1.14); }
      100% { transform: scale(1.09) translate(1.2%, 1.1%);  filter: hue-rotate(30deg) saturate(1.38); }
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <div class="fallback" id="fallback"></div>
  <div class="film"></div>

  <script>
  (() => {
    const canvas = document.getElementById('gl');
    const fallback = document.getElementById('fallback');

    const gl = canvas.getContext('webgl', {
      alpha: false,
      antialias: false,
      depth: false,
      stencil: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false,
      powerPreference: 'high-performance'
    });

    if (!gl) {
      fallback.style.display = 'block';
      return;
    }

    const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const VERT = `
      attribute vec2 a_pos;
      varying vec2 v_uv;
      void main() {
        v_uv = a_pos * 0.5 + 0.5;
        gl_Position = vec4(a_pos, 0.0, 1.0);
      }
    `;

    const SIM_FRAG = `
      precision highp float;
      varying vec2 v_uv;
      uniform sampler2D u_prev;
      uniform vec2 u_res;
      uniform vec2 u_mouse;
      uniform float u_time;
      uniform float u_dt;

      #define TAU 6.28318530718
      #define PI 3.14159265359

      mat2 rot(float a){
        float s = sin(a), c = cos(a);
        return mat2(c,-s,s,c);
      }

      float hash21(vec2 p){
        p = fract(p * vec2(234.34, 435.345));
        p += dot(p, p + 34.23);
        return fract(p.x * p.y);
      }

      float noise(vec2 p){
        vec2 i = floor(p);
        vec2 f = fract(p);
        vec2 u = f*f*(3.0-2.0*f);
        float a = hash21(i + vec2(0.0, 0.0));
        float b = hash21(i + vec2(1.0, 0.0));
        float c = hash21(i + vec2(0.0, 1.0));
        float d = hash21(i + vec2(1.0, 1.0));
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
      }

      float fbm(vec2 p){
        float v = 0.0;
        float a = 0.56;
        mat2 m = mat2(1.6, 1.2, -1.2, 1.6);
        for(int i=0;i<6;i++){
          v += a * noise(p);
          p = m * p;
          a *= 0.53;
        }
        return v;
      }

      vec2 flow(vec2 p, float t){
        float a = fbm(p*1.55 + vec2(0.0, t*0.12));
        float b = fbm((p+vec2(4.2,-3.1))*1.9 + vec2(-t*0.11, t*0.09));
        float c = fbm((p-vec2(1.9,2.7))*2.6 + vec2(t*0.06, -t*0.08));
        float ang = TAU*(a - b + 0.35*c);
        return vec2(cos(ang), sin(ang));
      }

      vec3 hsv2rgb(vec3 c){
        vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);
        rgb = rgb*rgb*(3.0-2.0*rgb);
        return c.z * mix(vec3(1.0), rgb, c.y);
      }

      float filament(vec2 p, float t, float freq, float thick, float warp){
        p += warp * vec2(
          sin(p.y*1.7 + t*0.7) + 0.5*sin(p.y*3.2 - t*0.3),
          cos(p.x*1.3 - t*0.6) + 0.5*cos(p.x*2.6 + t*0.25)
        );
        float f = abs(sin(p.x*freq + 0.8*sin(p.y*2.4 + t*0.9) + t*0.45));
        return smoothstep(thick, 0.0, f);
      }

      vec2 kaleido(vec2 p, float slices){
        float r = length(p);
        float a = atan(p.y, p.x);
        float seg = TAU / max(2.0, slices);
        a = mod(a + seg*0.5, seg) - seg*0.5;
        a = abs(a);
        return vec2(cos(a), sin(a))*r;
      }

      vec3 sampleSoft(sampler2D tex, vec2 uv, vec2 px){
        // energy-damped kernel (sum < 1.0)
        vec3 c = texture2D(tex, uv).rgb * 0.20;
        c += texture2D(tex, uv + vec2(px.x, 0.0)).rgb * 0.10;
        c += texture2D(tex, uv - vec2(px.x, 0.0)).rgb * 0.10;
        c += texture2D(tex, uv + vec2(0.0, px.y)).rgb * 0.10;
        c += texture2D(tex, uv - vec2(0.0, px.y)).rgb * 0.10;
        c += texture2D(tex, uv + vec2( px.x,  px.y)).rgb * 0.055;
        c += texture2D(tex, uv + vec2(-px.x,  px.y)).rgb * 0.055;
        c += texture2D(tex, uv + vec2( px.x, -px.y)).rgb * 0.055;
        c += texture2D(tex, uv + vec2(-px.x, -px.y)).rgb * 0.055;
        return c;
      }

      vec3 laplace(sampler2D tex, vec2 uv, vec2 px){
        vec3 c = texture2D(tex, uv).rgb;
        vec3 n = texture2D(tex, uv + vec2(0.0, px.y)).rgb;
        vec3 s = texture2D(tex, uv - vec2(0.0, px.y)).rgb;
        vec3 e = texture2D(tex, uv + vec2(px.x, 0.0)).rgb;
        vec3 w = texture2D(tex, uv - vec2(px.x, 0.0)).rgb;
        return (n+s+e+w - 4.0*c);
      }

      void main(){
        vec2 uv = v_uv;
        vec2 res = u_res;
        vec2 px = 1.0 / res;

        vec2 aspect = vec2(res.x / res.y, 1.0);
        vec2 p = (uv - 0.5) * aspect;
        vec2 m = (u_mouse / res - 0.5) * 2.0;
        m.x *= res.x / res.y;

        float t = u_time;

        // hyper-abstract fold
        float slices = 5.0 + 5.0*(0.5 + 0.5*sin(t*0.11));
        vec2 kp = kaleido(p * rot(0.13*sin(t*0.19)), slices);

        vec2 v = flow(kp*2.25, t);
        vec2 drift = vec2(sin(t*0.13), cos(t*0.11)) * 0.0009;

        float md = length(p - m*0.23);
        float attract = exp(-4.2 * md*md);
        vec2 mvec = normalize(p - m*0.23 + 1e-5) * attract * 0.0032;

        vec2 backUV = uv - v * (0.0030 + 0.0022*attract) - drift + mvec;

        vec3 adv = sampleSoft(u_prev, backUV, px * 1.20);
        vec3 loc = texture2D(u_prev, uv).rgb;
        vec3 diff = laplace(u_prev, uv, px*1.0);

        vec3 prev = mix(adv, loc + 0.19*diff, 0.36);

        // subtle chroma swirl in feedback
        prev = mix(prev, prev.gbr, 0.06 + 0.03*sin(t*0.31));

        // trail persistence (safe against whiteout)
        prev *= 0.949;

        // dream / cosmic field
        float cloud = fbm(kp*4.2 + vec2(t*0.22, -t*0.20));
        float detail = fbm(kp*10.2 - vec2(t*0.58, t*0.52));
        float beat = 0.5 + 0.5*sin(t*0.95 + cloud*3.8 + detail*2.4);

        // braided strings + polar threads
        vec2 q = kp;
        q += 0.28 * flow(q*1.9, t);
        q += 0.22 * flow(q*2.9 + 4.7, -t*0.90);
        q *= rot(0.35*sin(t*0.2 + cloud*2.2));

        float s1 = filament(q*1.28, t, 18.0, 0.102, 0.24);
        float s2 = filament((q.yx+vec2(0.34,-0.22))*1.14, -t*0.86 + 3.2, 15.0, 0.110, 0.26);
        float s3 = filament((q-vec2(0.20,0.28))*1.36, t*0.79 - 1.9, 22.0, 0.093, 0.20);

        float r = length(q);
        float a = atan(q.y, q.x);
        float polar = abs(sin(26.0*r - 5.0*a + t*0.75 + detail*1.2));
        float s4 = smoothstep(0.20, 0.0, polar);

        float knot = smoothstep(0.0, 1.0, s1*0.7 + s2*0.65 + s3*0.55 + s4*0.45);

        vec3 silk1 = hsv2rgb(vec3(fract(0.56 + t*0.020 + cloud*0.18), 0.78, 1.00));
        vec3 silk2 = hsv2rgb(vec3(fract(0.89 - t*0.016 + detail*0.12), 0.72, 1.00));
        vec3 silk3 = hsv2rgb(vec3(fract(0.72 + t*0.011 + beat*0.08), 0.62, 1.00));

        vec3 emit = vec3(0.0);
        emit += silk1 * pow(s1, 1.30) * (0.17 + 0.10*beat);
        emit += silk2 * pow(s2, 1.34) * (0.16 + 0.09*(1.0-beat));
        emit += silk3 * pow(s3, 1.45) * 0.12;
        emit += mix(silk1, silk2, 0.5) * pow(s4, 1.50) * 0.08;

        // prismatic haze
        vec3 haze = hsv2rgb(vec3(fract(0.18 + cloud*0.35 + t*0.01), 0.48, 0.90));
        emit += haze * (0.010 + 0.015*knot);

        // stochastic glints
        vec2 gId = floor((q + vec2(t*0.03, -t*0.02))*24.0);
        float rnd = hash21(gId);
        float glint = smoothstep(0.994, 1.0, rnd) * (0.6 + 0.4*sin(t*8.0 + rnd*60.0));
        emit += vec3(1.0, 0.95, 1.0) * glint * 0.050;

        // pointer halo
        float halo = exp(-5.5*dot(p - m*0.20, p - m*0.20));
        emit += mix(silk1, silk2, 0.5 + 0.5*sin(t*0.5)) * halo * 0.028;

        vec3 col = prev + emit;

        // stronger highlight compression
        float lum = dot(col, vec3(0.2126, 0.7152, 0.0722));
        col *= 1.0 - 0.36 * smoothstep(0.48, 1.20, lum);
        col = col / (1.0 + col * 0.82);

        // black floor lift
        col = max(col, vec3(0.00055, 0.00075, 0.0010));

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    const DISPLAY_FRAG = `
      precision highp float;
      varying vec2 v_uv;
      uniform sampler2D u_tex;
      uniform vec2 u_res;
      uniform float u_time;

      vec3 aces(vec3 x) {
        return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14), 0.0, 1.0);
      }

      vec3 bloom(sampler2D tex, vec2 uv, vec2 px){
        vec3 c = texture2D(tex, uv).rgb * 0.22;
        c += texture2D(tex, uv + vec2(px.x*2.0, 0.0)).rgb * 0.11;
        c += texture2D(tex, uv - vec2(px.x*2.0, 0.0)).rgb * 0.11;
        c += texture2D(tex, uv + vec2(0.0, px.y*2.0)).rgb * 0.11;
        c += texture2D(tex, uv - vec2(0.0, px.y*2.0)).rgb * 0.11;
        c += texture2D(tex, uv + vec2(px.x*3.0, px.y*3.0)).rgb * 0.07;
        c += texture2D(tex, uv + vec2(-px.x*3.0, px.y*3.0)).rgb * 0.07;
        c += texture2D(tex, uv + vec2(px.x*3.0, -px.y*3.0)).rgb * 0.07;
        c += texture2D(tex, uv + vec2(-px.x*3.0, -px.y*3.0)).rgb * 0.07;
        return c;
      }

      void main(){
        vec2 uv = v_uv;
        vec2 px = 1.0 / u_res;

        vec2 p = uv - 0.5;
        p.x *= u_res.x / u_res.y;
        float rr = length(p);

        // radial chromatic dispersion
        vec2 dir = normalize(p + 1e-6);
        float disp = (0.35 + 0.65*smoothstep(0.1, 1.0, rr)) * (0.8 + 0.2*sin(u_time*0.7));
        vec2 off = dir * px * 2.0 * disp;

        vec3 r = texture2D(u_tex, uv + off).rgb;
        vec3 g = texture2D(u_tex, uv).rgb;
        vec3 b = texture2D(u_tex, uv - off).rgb;
        vec3 col = vec3(r.r, g.g, b.b);

        vec3 bl = bloom(u_tex, uv, px);
        col += bl * 0.22;

        // shimmer / phase pulse
        float sh = 0.5 + 0.5*sin(u_time*0.9 + uv.x*9.0 + uv.y*7.0 + rr*20.0);
        col *= 0.982 + 0.03*sh;

        // grade
        col = aces(max(col, 0.0));
        col = pow(col, vec3(0.92, 0.95, 0.97));
        col = mix(vec3(dot(col, vec3(0.299, 0.587, 0.114))), col, 1.18);

        float vign = smoothstep(1.02, 0.13, rr);
        col *= vign;

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function createShader(type, source) {
      const s = gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        const log = gl.getShaderInfoLog(s);
        gl.deleteShader(s);
        throw new Error(log || 'Shader compile failed');
      }
      return s;
    }

    function createProgram(vs, fs) {
      const p = gl.createProgram();
      const sv = createShader(gl.VERTEX_SHADER, vs);
      const sf = createShader(gl.FRAGMENT_SHADER, fs);
      gl.attachShader(p, sv);
      gl.attachShader(p, sf);
      gl.linkProgram(p);
      gl.deleteShader(sv);
      gl.deleteShader(sf);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        const log = gl.getProgramInfoLog(p);
        gl.deleteProgram(p);
        throw new Error(log || 'Program link failed');
      }
      return p;
    }

    let simProgram, displayProgram;
    try {
      simProgram = createProgram(VERT, SIM_FRAG);
      displayProgram = createProgram(VERT, DISPLAY_FRAG);
    } catch (err) {
      console.error(err);
      canvas.style.display = 'none';
      fallback.style.display = 'block';
      return;
    }

    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    function createTexture(w, h) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      return tex;
    }

    function createFBO(tex) {
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      const ok = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
      if (!ok) throw new Error('Framebuffer incomplete');
      return fbo;
    }

    let simW = 1, simH = 1;
    let texA, texB, fboA, fboB;

    function destroyPingPong() {
      if (texA) gl.deleteTexture(texA);
      if (texB) gl.deleteTexture(texB);
      if (fboA) gl.deleteFramebuffer(fboA);
      if (fboB) gl.deleteFramebuffer(fboB);
      texA = texB = fboA = fboB = null;
    }

    function makePingPong() {
      destroyPingPong();
      texA = createTexture(simW, simH);
      texB = createTexture(simW, simH);
      fboA = createFBO(texA);
      fboB = createFBO(texB);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboA);
      gl.viewport(0, 0, simW, simH);
      gl.clearColor(0.008, 0.010, 0.016, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.bindFramebuffer(gl.FRAMEBUFFER, fboB);
      gl.viewport(0, 0, simW, simH);
      gl.clearColor(0.008, 0.010, 0.016, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const cw = Math.max(1, Math.floor(window.innerWidth * dpr));
      const ch = Math.max(1, Math.floor(window.innerHeight * dpr));

      if (canvas.width !== cw || canvas.height !== ch) {
        canvas.width = cw;
        canvas.height = ch;
      }

      // softened sim resolution for painterly abstraction
      const scale = reducedMotion ? 0.45 : 0.70;
      const nw = Math.max(2, Math.floor(cw * scale));
      const nh = Math.max(2, Math.floor(ch * scale));

      if (nw !== simW || nh !== simH) {
        simW = nw;
        simH = nh;
        makePingPong();
      }

      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    const pointer = { x: 0.5, y: 0.5 };
    const target = { x: 0.5, y: 0.5 };

    function setPointer(clientX, clientY) {
      target.x = clientX / window.innerWidth;
      target.y = 1.0 - clientY / window.innerHeight;
    }

    window.addEventListener('mousemove', (e) => setPointer(e.clientX, e.clientY), { passive: true });
    window.addEventListener('touchmove', (e) => {
      const t = e.touches && e.touches[0];
      if (t) setPointer(t.clientX, t.clientY);
    }, { passive: true });
    window.addEventListener('resize', resize, { passive: true });

    resize();

    function setupAttrib(program) {
      const loc = gl.getAttribLocation(program, 'a_pos');
      gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    }

    const simLoc = {
      u_prev: gl.getUniformLocation(simProgram, 'u_prev'),
      u_res: gl.getUniformLocation(simProgram, 'u_res'),
      u_mouse: gl.getUniformLocation(simProgram, 'u_mouse'),
      u_time: gl.getUniformLocation(simProgram, 'u_time'),
      u_dt: gl.getUniformLocation(simProgram, 'u_dt')
    };

    const dispLoc = {
      u_tex: gl.getUniformLocation(displayProgram, 'u_tex'),
      u_res: gl.getUniformLocation(displayProgram, 'u_res'),
      u_time: gl.getUniformLocation(displayProgram, 'u_time')
    };

    let readTex = texA, writeTex = texB;
    let readFbo = fboA, writeFbo = fboB;

    function swap() {
      [readTex, writeTex] = [writeTex, readTex];
      [readFbo, writeFbo] = [writeFbo, readFbo];
    }

    const start = performance.now();
    let last = start;
    let running = true;
    let pausedAccum = 0;
    let hideStart = 0;

    function render(now) {
      if (!running) return;

      let dt = (now - last) * 0.001;
      last = now;
      dt = Math.min(0.05, Math.max(0.001, dt));

      const elapsed = (now - start - pausedAccum) * 0.001;
      const t = reducedMotion ? elapsed * 0.28 : elapsed;

      pointer.x += (target.x - pointer.x) * 0.06;
      pointer.y += (target.y - pointer.y) * 0.06;

      // SIM PASS
      gl.useProgram(simProgram);
      setupAttrib(simProgram);

      gl.bindFramebuffer(gl.FRAMEBUFFER, writeFbo);
      gl.viewport(0, 0, simW, simH);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, readTex);
      gl.uniform1i(simLoc.u_prev, 0);
      gl.uniform2f(simLoc.u_res, simW, simH);
      gl.uniform2f(simLoc.u_mouse, pointer.x * simW, pointer.y * simH);
      gl.uniform1f(simLoc.u_time, t);
      gl.uniform1f(simLoc.u_dt, dt);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      swap();

      // DISPLAY PASS
      gl.useProgram(displayProgram);
      setupAttrib(displayProgram);

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, readTex);
      gl.uniform1i(dispLoc.u_tex, 0);
      gl.uniform2f(dispLoc.u_res, canvas.width, canvas.height);
      gl.uniform1f(dispLoc.u_time, t);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        hideStart = performance.now();
        running = false;
      } else {
        if (hideStart) pausedAccum += performance.now() - hideStart;
        running = true;
        last = performance.now();
        requestAnimationFrame(render);
      }
    });

    requestAnimationFrame(render);
  })();
  </script>
</body>
</html>